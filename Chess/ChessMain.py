"""
This is the main driver file. Includes loading of different objects.
"""

import pygame as pg

from Chess import ChessEngine

# Constants for the window and chessboard
WIDTH = HEIGHT = 512
DIMENSION = 8  # Dimension of the chess board (8x8)
SQ_SIZE = HEIGHT // DIMENSION
MAX_FPS = 144  # For animations
IMAGES = {}


# Responsible for loading the images into the dictionary
def load_images():
    pieces = ["wP", "wR", "wN", "wB", "wQ", "wK", "bP", "bR", "bN", "bB", "bQ", "bK"]
    for piece in pieces:
        IMAGES[piece] = pg.transform.scale(
            pg.image.load("images/" + piece + ".png"), (SQ_SIZE, SQ_SIZE)
        )


# Main driver function
def main():
    pg.init()
    screen = pg.display.set_mode((WIDTH, HEIGHT))
    pg.display.set_caption("Square Logic")
    clock = pg.time.Clock()
    screen.fill(pg.Color("white"))
    game_state = ChessEngine.GameState()
    valid_moves = game_state.get_valid_moves()
    move_made = False  # Flag that checks weather the user has made a move
    promotion_type = "Q"

    load_images()  # Load the images

    running = True
    sq_selected = ()  # Keeps track of the selected square (row, col)
    player_clicks = []  # List of selected squares.

    while running:
        for event in pg.event.get():
            if event.type == pg.QUIT:
                running = False
            elif event.type == pg.MOUSEBUTTONDOWN:
                mouse_pos = pg.mouse.get_pos()  # (x, y) position of the mouse
                col = mouse_pos[0] // SQ_SIZE
                row = mouse_pos[1] // SQ_SIZE

                if sq_selected == (row, col):  # Deselect square if clicked twice
                    sq_selected = ()
                    player_clicks = []
                elif game_state.board[row][col] != "--" or len(player_clicks) == 1:
                    sq_selected = (row, col)
                    player_clicks.append(sq_selected)

                if len(player_clicks) == 2:  # After two clicks, make a move
                    move = ChessEngine.Move(player_clicks[0], player_clicks[1], game_state.board)
                    print(move.get_chess_notation())
                    for i in range(len(valid_moves)):
                        '''
                        This allows us to use the move generated by the engine thus they can be more complex,
                        In the sense of the information about the move.Also keep the player moves simple and 
                        isolated.
                        '''
                        if move == valid_moves[i]:
                            if move.is_pawn_promotion:
                                game_state.make_move(valid_moves[i], promotion_type)
                            else:
                                game_state.make_move(valid_moves[i])
                            move_made = True
                            sq_selected = ()  # Reset user selection
                            player_clicks = []
                    if not move_made:
                        player_clicks = [sq_selected]
            # Handles the keys.
            elif event.type == pg.KEYDOWN:
                if event.key == pg.K_BACKSPACE:
                    game_state.undo_move()
                    move_made = True

        mouse_pos = pg.mouse.get_pos()
        hover_square = (mouse_pos[1] // SQ_SIZE, mouse_pos[0] // SQ_SIZE)

        draw_game_state(screen, game_state, hover_square, sq_selected, valid_moves)
        clock.tick(MAX_FPS)
        pg.display.flip()

        if move_made:
            valid_moves = game_state.get_valid_moves()
            move_made = False


# Responsible for rendering the game state
def draw_game_state(screen, game_state, hover_square, sq_selected, valid_moves):
    draw_board(screen, hover_square)  # Draw the squares
    highlight_squares(screen, game_state, valid_moves, sq_selected)
    draw_pieces(screen, game_state.board)  # Draw the pieces on top of the squares


# Draw the board (alternating colors)
def draw_board(screen, hover_square):
    colors = [pg.Color(255, 206, 158), pg.Color(209, 139, 71)]

    for row in range(DIMENSION):
        for col in range(DIMENSION):
            color = colors[(row + col) % 2]

            pg.draw.rect(screen, color, pg.Rect(col * SQ_SIZE, row * SQ_SIZE, SQ_SIZE, SQ_SIZE))

            # Highlight hover square
            if hover_square == (row, col):
                pg.draw.rect(screen, "yellow", pg.Rect(col * SQ_SIZE, row * SQ_SIZE, SQ_SIZE, SQ_SIZE), 3)


# Draw the pieces on the board
def draw_pieces(screen, board):
    for row in range(DIMENSION):
        for col in range(DIMENSION):
            piece = board[row][col]
            if piece != "--":  # If not an empty square
                screen.blit(IMAGES[piece], pg.Rect(col * SQ_SIZE, row * SQ_SIZE, SQ_SIZE, SQ_SIZE))


# Draw moves and selected square
def highlight_squares(screen, game_state, valid_moves, sq_selected):
    if sq_selected != ():
        r, c = sq_selected
        if game_state.board[r][c][0] == ("w" if game_state.white_to_move else "b"):
            # Highlight selected square with a yellowish tint
            pg.draw.rect(screen, pg.Color(255, 255, 100, 100), (c * SQ_SIZE, r * SQ_SIZE, SQ_SIZE, SQ_SIZE), 0)

            # Highlight valid move destinations with a grayish circle
            for move in valid_moves:
                if move.start_row == r and move.start_col == c:
                    center = ((move.end_col * SQ_SIZE) + SQ_SIZE // 2, (move.end_row * SQ_SIZE) + SQ_SIZE // 2)
                    radius = SQ_SIZE // 6  # Small indicator in the center
                    pg.draw.circle(screen, pg.Color(128, 128, 128, 180), center, radius)


if __name__ == "__main__":
    main()
